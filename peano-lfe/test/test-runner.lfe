#!/usr/bin/env lfescript
;;; Main test runner for all Peano-LFE modules

(defun main (args)
  (io:format "~n=== Peano-LFE Test Suite ===~n~n")
  
  ;; Run tests based on arguments
  (cond
    ((null args) (run-all-tests))
    ((equal? args '("peano")) (test-peano))
    ((equal? args '("arithmetic")) (test-arithmetic))
    ((equal? args '("pairs")) (test-pairs))
    ((equal? args '("lists")) (test-lists))
    ((equal? args '("tuples")) (test-tuples))
    ((equal? args '("records")) (test-records))
    ((equal? args '("adt")) (test-adt))
    ((equal? args '("vectors")) (test-vectors))
    ((equal? args '("maps")) (test-maps))
    ((equal? args '("sets")) (test-sets))
    ((equal? args '("all")) (run-all-tests))
    ('true (io:format "Usage: ./test-runner.lfe [module-name|all]~n"))))

(defun run-all-tests ()
  (test-peano)
  (test-arithmetic)
  (test-pairs)
  (test-lists)
  (test-tuples)
  (test-records)
  (test-adt)
  (test-vectors)
  (test-maps)
  (test-sets)
  (io:format "~n=== All tests completed ===~n"))

;; Test framework helpers
(defun assert-equal (expected actual msg)
  (if (equal? expected actual)
      (io:format "  ✓ ~s~n" (list msg))
      (io:format "  ✗ ~s~n    Expected: ~p~n    Actual: ~p~n" 
                 (list msg expected actual))))

(defun equal? (a b)
  ;; Deep equality check
  (cond
    ((and (is_atom a) (is_atom b)) (=:= a b))
    ((and (is_number a) (is_number b)) (=:= a b))
    ((and (is_tuple a) (is_tuple b))
     (equal-tuples? (tuple_to_list a) (tuple_to_list b)))
    ((and (is_list a) (is_list b))
     (equal-lists? a b))
    ('true 'false)))

(defun equal-lists? (l1 l2)
  (cond
    ((and (null l1) (null l2)) 'true)
    ((or (null l1) (null l2)) 'false)
    ('true (and (equal? (car l1) (car l2)) 
                (equal-lists? (cdr l1) (cdr l2))))))

(defun equal-tuples? (l1 l2)
  (equal-lists? l1 l2))

;; Individual test modules
(defun test-peano ()
  (io:format "Testing peano module...~n")
  (let* ((zero (peano:zero))
         (one (peano:s zero))
         (two (peano:s one))
         (three (peano:s two)))
    (assert-equal 'true (peano:zero? zero) "zero? identifies zero")
    (assert-equal 'false (peano:zero? one) "zero? rejects non-zero")
    (assert-equal 'true (peano:eq zero zero) "zero equals zero")
    (assert-equal 'true (peano:eq two two) "two equals two")
    (assert-equal 'false (peano:eq one two) "one not equal two")
    (assert-equal 'true (peano:lt one two) "one less than two")
    (assert-equal 'false (peano:lt two one) "two not less than one")
    (assert-equal zero (peano:p one) "predecessor of one is zero")
    (assert-equal 3 (peano:peano->nat three) "peano->nat conversion")
    (assert-equal 'true (peano:eq three (peano:nat->peano 3)) "nat->peano conversion")))

(defun test-arithmetic ()
  (io:format "~nTesting arithmetic module...~n")
  (let* ((two (peano:nat->peano 2))
         (three (peano:nat->peano 3))
         (five (peano:nat->peano 5))
         (six (peano:nat->peano 6)))
    (assert-equal 5 (peano:peano->nat (arithmetic:add two three)) "2 + 3 = 5")
    (assert-equal 6 (peano:peano->nat (arithmetic:mult two three)) "2 * 3 = 6")
    (assert-equal 8 (peano:peano->nat (arithmetic:pow two three)) "2^3 = 8")
    (assert-equal 2 (peano:peano->nat (arithmetic:sub five three)) "5 - 3 = 2")
    (assert-equal 1 (peano:peano->nat (arithmetic:div five three)) "5 / 3 = 1")
    (assert-equal 2 (peano:peano->nat (arithmetic:mod five three)) "5 % 3 = 2")
    (assert-equal 120 (peano:peano->nat (arithmetic:fact five)) "5! = 120")
    (assert-equal 'true (arithmetic:prime? five) "5 is prime")
    (assert-equal 'false (arithmetic:prime? six) "6 is not prime")))

(defun test-pairs ()
  (io:format "~nTesting pairs module...~n")
  (let* ((p (pairs:pair (peano:nat->peano 7) (peano:nat->peano 11)))
         (a (pairs:first p))
         (b (pairs:second p)))
    (assert-equal 7 (peano:peano->nat a) "first of pair(7,11) = 7")
    (assert-equal 11 (peano:peano->nat b) "second of pair(7,11) = 11")
    (let ((p2 (pairs:set-binary-head p (peano:nat->peano 5))))
      (assert-equal 5 (peano:peano->nat (pairs:first p2)) "set first to 5")
      (assert-equal 11 (peano:peano->nat (pairs:second p2)) "second unchanged"))))

(defun test-lists ()
  (io:format "~nTesting lists module...~n")
  (let* ((lst (lists:list (peano:nat->peano 1)
                         (peano:nat->peano 2)
                         (peano:nat->peano 3)))
         (len (lists:length lst))
         (rev (lists:reverse lst)))
    (assert-equal 3 (peano:peano->nat len) "list length = 3")
    (assert-equal 1 (peano:peano->nat (lists:head lst)) "head = 1")
    (assert-equal 3 (peano:peano->nat (lists:head rev)) "reversed head = 3")
    (assert-equal 'true (lists:member? (peano:nat->peano 2) lst) "2 is member")
    (assert-equal 'false (lists:member? (peano:nat->peano 4) lst) "4 not member")))

(defun test-tuples ()
  (io:format "~nTesting tuples module...~n")
  (let* ((t (tuples:tuple (peano:nat->peano 1)
                         (peano:nat->peano 2)
                         (peano:nat->peano 3)))
         (arity (tuples:tuple-arity t)))
    (assert-equal 3 (peano:peano->nat arity) "tuple arity = 3")
    (assert-equal 1 (peano:peano->nat (tuples:tuple-ref t (peano:zero))) "first element = 1")
    (assert-equal 2 (peano:peano->nat (tuples:tuple-ref t (peano:s (peano:zero)))) "second element = 2")
    (assert-equal 'true (tuples:is-tuple? t) "is-tuple? returns true")))

(defun test-records ()
  (io:format "~nTesting records module...~n")
  (let* ((person (records:make-person (peano:nat->peano 25) (peano:nat->peano 30)))
         (age (records:person-age person))
         (updated (records:record-set person (records:age-field) (peano:nat->peano 31))))
    (assert-equal 30 (peano:peano->nat age) "person age = 30")
    (assert-equal 31 (peano:peano->nat (records:person-age updated)) "updated age = 31")
    (assert-equal 'true (records:is-record? person) "is-record? returns true")))

(defun test-adt ()
  (io:format "~nTesting ADT module...~n")
  (let* ((none (adt:none))
         (some (adt:some (peano:nat->peano 42)))
         (left (adt:left (peano:nat->peano 1)))
         (right (adt:right (peano:nat->peano 2))))
    (assert-equal 'true (adt:is-none? none) "is-none? identifies none")
    (assert-equal 'true (adt:is-some? some) "is-some? identifies some")
    (assert-equal 42 (peano:peano->nat (adt:some-value some)) "extract some value")
    (assert-equal 'true (adt:is-left? left) "is-left? identifies left")
    (assert-equal 'true (adt:is-right? right) "is-right? identifies right")))

(defun test-vectors ()
  (io:format "~nTesting vectors module...~n")
  (let* ((vec (vectors:vector-from-list 
               (lists:list (peano:nat->peano 10)
                          (peano:nat->peano 20)
                          (peano:nat->peano 30))))
         (size (vectors:vector-size vec))
         (elem (vectors:vector-ref vec (peano:s (peano:zero)))))
    (assert-equal 3 (peano:peano->nat size) "vector size = 3")
    (assert-equal 20 (peano:peano->nat elem) "vector[1] = 20")
    (let ((updated (vectors:vector-set vec (peano:zero) (peano:nat->peano 15))))
      (assert-equal 15 (peano:peano->nat (vectors:vector-ref updated (peano:zero))) "updated vector[0] = 15"))))

(defun test-maps ()
  (io:format "~nTesting maps module...~n")
  (let* ((m (maps:map-from-list 
             (lists:list (pairs:pair (peano:nat->peano 1) (peano:nat->peano 10))
                        (pairs:pair (peano:nat->peano 2) (peano:nat->peano 20)))))
         (val (maps:map-get m (peano:nat->peano 1))))
    (assert-equal 'true (not (adt:is-none? val)) "key 1 exists")
    (assert-equal 10 (peano:peano->nat (adt:some-value val)) "map[1] = 10")
    (assert-equal 'true (maps:map-has-key? m (peano:nat->peano 1)) "has-key? returns true")
    (assert-equal 'false (maps:map-has-key? m (peano:nat->peano 3)) "has-key? returns false for missing")))

(defun test-sets ()
  (io:format "~nTesting sets module...~n")
  (let* ((s1 (sets:set-from-list (lists:list (peano:nat->peano 1)
                                             (peano:nat->peano 2)
                                             (peano:nat->peano 3))))
         (s2 (sets:set-from-list (lists:list (peano:nat->peano 2)
                                             (peano:nat->peano 3)
                                             (peano:nat->peano 4))))
         (union (sets:set-union s1 s2))
         (inter (sets:set-intersection s1 s2)))
    (assert-equal 3 (peano:peano->nat (sets:set-size s1)) "set1 size = 3")
    (assert-equal 4 (peano:peano->nat (sets:set-size union)) "union size = 4")
    (assert-equal 2 (peano:peano->nat (sets:set-size inter)) "intersection size = 2")
    (assert-equal 'true (sets:set-member? s1 (peano:nat->peano 1)) "1 in set1")
    (assert-equal 'false (sets:set-member? s1 (peano:nat->peano 4)) "4 not in set1")))